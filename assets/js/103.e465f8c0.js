(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{991:function(t,a,_){"use strict";_.r(a);var v=_(106),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注解"}},[t._v("#")]),t._v(" 注解")]),t._v(" "),_("p",[t._v("提供一种为程序元素设置元数据的方法")]),t._v(" "),_("ol",[_("li",[t._v("元数据是添加到程序元素（如：方法、字段、类和包）上的额外信息")]),t._v(" "),_("li",[t._v("注解是一种分散式的元数据设置方式，XML是集中式的设置方式")]),t._v(" "),_("li",[t._v("注解不能直接干扰程序代码的运行")]),t._v(" "),_("li",[t._v("反编译是继承自Annotation接口")])]),t._v(" "),_("h2",{attrs:{id:"一、功能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、功能"}},[t._v("#")]),t._v(" 一、功能：")]),t._v(" "),_("ol",[_("li",[t._v("作为特定的标记，用于告诉编译器一些信息")]),t._v(" "),_("li",[t._v("编译时动态处理，如动态生成代码")]),t._v(" "),_("li",[t._v("运行时动态处理，作为额外信息的载体，如获取注解信息")])]),t._v(" "),_("h2",{attrs:{id:"二、分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、分类"}},[t._v("#")]),t._v(" 二、分类：")]),t._v(" "),_("h3",{attrs:{id:"_1-标准注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-标准注解"}},[t._v("#")]),t._v(" 1. 标准注解")]),t._v(" "),_("p",[t._v("@Override")]),t._v(" "),_("h3",{attrs:{id:"_2-元注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-元注解"}},[t._v("#")]),t._v(" 2. 元注解")]),t._v(" "),_("p",[t._v("定义annotation的annotation：")]),t._v(" "),_("ol",[_("li",[t._v("@Target：注解的作用目标")]),t._v(" "),_("li",[t._v("@Retention：注解的生命周期")]),t._v(" "),_("li",[t._v("@Documented：注解是否应当被包含在JavaDoc文档中")]),t._v(" "),_("li",[t._v("@Inherited：是否允许子类继承该注解")])]),t._v(" "),_("h3",{attrs:{id:"_3-自定义注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-自定义注解"}},[t._v("#")]),t._v(" 3. 自定义注解")]),t._v(" "),_("ol",[_("li",[t._v("支持所有基本数据类型+String+Class+Enum+Annotation，以及以上类型的数组\n"),_("ad"),t._v(" "),_("comment")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);