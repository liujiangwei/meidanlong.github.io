(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{872:function(v,l,_){"use strict";_.r(l);var i=_(106),e=Object(i.a)({},(function(){var v=this,l=v.$createElement,_=v._self._c||l;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),_("h2",{attrs:{id:"三个问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三个问题"}},[v._v("#")]),v._v(" 三个问题")]),v._v(" "),_("ol",[_("li",[v._v("什么场景下使用什么垃圾回收策略\n"),_("ul",[_("li",[v._v("对内存要求苛刻的场景：想办法提高对象的回收效率，多回收掉一些对象，腾出更多的空间")]),v._v(" "),_("li",[v._v("CPU使用率高的情况下：降低高并发时垃圾回收的频率，让CPU更多的去执行你的业务而不是垃圾回收")])])]),v._v(" "),_("li",[v._v("垃圾回收主要发生在哪些区域\n"),_("ul",[_("li",[v._v("线程隔离区域，随着线程的创建而创建，随着线程的消亡而消亡")]),v._v(" "),_("li",[v._v("堆和方法区是需要考虑垃圾回收的区域，而堆是垃圾回收的主要区域，主要回收的是我们创建的对象。而方法区则回收废弃的常量和不需要使用的类")])])]),v._v(" "),_("li",[v._v("对象在什么时候能被回收呢？主要有两种算法\n"),_("ol",[_("li",[v._v("引用计数法： 通过对象的引用计数器来判断对象是否被引用了。\n"),_("ul",[_("li",[v._v("只要有一个对象引用了对象A，A的引用计数器就会加1，同理当引用失效的时候，A的引用计数器就会减1。如果A的引用计数器的值变为0的话，就说明没有对象引用了")]),v._v(" "),_("li",[v._v("引用计数法简单高效，但是无法解决循环引用的情况，所以java不选择该算法")])])]),v._v(" "),_("li",[v._v("可达性分析：以根对象（GC Roots）作为起点向下搜索，走过的路径被称为引用链（Reference Chain），如果某个对象到根对象没有引用链时，就认为这个对象是不可达的，可以回收\n"),_("ul",[_("li",[v._v("那么哪些对象可以作为根对象呢？")])]),v._v(" "),_("ol",[_("li",[v._v("虚拟机栈（栈帧中的本地变量表）中引用的对象 -> 一般是一些局部变量")]),v._v(" "),_("li",[v._v("方法区中类静态属性引用的对象")]),v._v(" "),_("li",[v._v("方法区中常量引用的对象")]),v._v(" "),_("li",[v._v("本地方法栈中JNI（即native方法）引用的对象")])]),v._v(" "),_("ul",[_("li",[v._v("什么是引用呢？")])]),v._v(" "),_("ol",[_("li",[v._v("强引用 new出来的对象引用，只要强引用存在，永远不会回收被引用的对象，哪怕是内存溢出")]),v._v(" "),_("li",[v._v("软引用 "),_("code",[v._v("SoftReference<String>")]),v._v(" 用来描述有用，但不是必须的对象。软引用关联的对象只有在内存不足的时候才会被回收。比价时候做缓存，如网页缓存、图片缓存等")]),v._v(" "),_("li",[v._v("弱引用 "),_("code",[v._v("WeakReference<String>")]),v._v(" 也是用来描述非必需对象的，当JVM垃圾回收的时候，不管内存是否充足都会回收被弱引用关联的对象")]),v._v(" "),_("li",[v._v("虚引用 "),_("code",[v._v("ReferenceQueue<String>")]),v._v(" 不影响对象的生命周期，如果一个对象只有虚引用，就相当于没有引用一样，在任何时候都有可能被垃圾回收，主要用于跟踪对象被垃圾回收器回收的活动，需配合引用队列使用")])]),v._v(" "),_("ul",[_("li",[v._v("可达性算法注意点")])]),v._v(" "),_("ol",[_("li",[v._v("一个对象不可达，也不一定会被回收，只是死缓")]),v._v(" "),_("li",[v._v("想要真正处死一个对象的流程大致是这样的\n"),_("ol",[_("li",[v._v("符合对象没有引用链和GC Roots链接")]),v._v(" "),_("li",[v._v("有无必要执行finalize()")]),v._v(" "),_("li",[v._v("有必要的话，将对象放入F-Queue队列中，使用一个低优先级的线程来执行对象的finalize方法")]),v._v(" "),_("li",[v._v("如果在调用对象的finalize方法中，对象与其他对象重新建立连接，或者对象自救，则会将该对象从F-Queue队列中移除")]),v._v(" "),_("li",[v._v("否则的话，则会回收该对象")])])])])])])])]),v._v(" "),_("h2",{attrs:{id:"垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[v._v("#")]),v._v(" 垃圾回收算法")]),v._v(" "),_("ol",[_("li",[v._v("标记 - 清除：\n"),_("ol",[_("li",[v._v("标记需要回收的对象")]),v._v(" "),_("li",[v._v("清理掉需要回收的对象")]),v._v(" "),_("li",[v._v("缺点：\n"),_("ol",[_("li",[v._v("遍历空闲链表需要消耗时间，极端情况下需要遍历完全部链表才能确定对象该分配到哪里去，或者无法分配")]),v._v(" "),_("li",[v._v("效率不高，标记和清除的效率都不高")]),v._v(" "),_("li",[v._v("标记清除后产生大量不连续的内存碎片，从而导致在分配大对象时触发GC")])])])])]),v._v(" "),_("li",[v._v("复制：\n"),_("ol",[_("li",[v._v("把内存分为两块，每次只使用其中的一块")]),v._v(" "),_("li",[v._v("将正在使用中的内存中的存活对象，复制到未使用的内存中去，然后清除掉正在使用的的内存中的所有对象")]),v._v(" "),_("li",[v._v("交换两个内存的角色，等待下一次被回收")]),v._v(" "),_("li",[v._v("hotSpot默认Eden和Survivor比是8:1，也就是每次能使用90%的新生代空间")]),v._v(" "),_("li",[v._v("如果Survivor空间不够，就要依赖老年代进行分配担保，把放不下的对象直接进入老年代。什么是分配担保？\n"),_("ul",[_("li",[v._v("新生代空间放置不下：1. 对象很多，Eden+某一块Survivor区的对象空间 > Eden+另一块Survivor区的空间。 2. 新对象很大，大于新生代剩余空间")]),v._v(" "),_("li",[v._v("Minor GC前，JVM会检查老年代的最大可用的连续空间，是否大于新生代所有对象的总空间，如果大于，可以确保Minor GC是安全的")]),v._v(" "),_("li",[v._v("如果小于，JVM会首先检查是否设置了允许担保失败，如果允许，则检查老年代最大可用连续空间，是否大于历次晋升到老年代对象的平均大小")]),v._v(" "),_("li",[v._v("如果老年代可以空间大于历次晋升到老年代对象的平均大小，尝试一次MinorGC")]),v._v(" "),_("li",[v._v("否则执行fullGC")])])]),v._v(" "),_("li",[v._v("缺点：\n"),_("ol",[_("li",[v._v("内存利用率低")])])])])]),v._v(" "),_("li",[v._v("标记 - 整理：\n"),_("ol",[_("li",[v._v("标记需要回收的对象")]),v._v(" "),_("li",[v._v("把存活的对象压缩到内存的一端")]),v._v(" "),_("li",[v._v("清除掉边界外的所有空间")]),v._v(" "),_("li",[v._v("缺点：\n"),_("ol",[_("li",[v._v("整理存在开销")])])])])]),v._v(" "),_("li",[v._v("分代收集算法\n"),_("ul",[_("li",[v._v("新生代回收（Minor GC ｜ Young GC）\n"),_("ul",[_("li",[v._v("触发条件：Eden空间不足")])])]),v._v(" "),_("li",[v._v("老年代回收 (Major GC)，Major GC 时常会伴随着 Minor GC，所以 Major GC 约等于 Full GC")]),v._v(" "),_("li",[v._v("清理整个堆（Full GC）\n"),_("ul",[_("li",[v._v("触发条件：\n"),_("ol",[_("li",[v._v("老年代空间不足：空间真的不足 和 内存碎片导致没有连续的内存")]),v._v(" "),_("li",[v._v("元空间不足")]),v._v(" "),_("li",[v._v("要晋升老年代的对象所占用的空间大于老年代剩余空间")]),v._v(" "),_("li",[v._v("显式的调用的System.gc()\n"),_("ul",[_("li",[v._v("建议垃圾回收器执行垃圾回收")]),v._v(" "),_("li",[v._v("-XX:+DisableExplicitGC 参数，忽略 System.gc() 调用")])])])])])])]),v._v(" "),_("li",[v._v("注意：\n"),_("ul",[_("li",[v._v("新建的对象不一定分配到伊甸园 ： 1. 大于 -XX:PretenureSizeThrehold 阈值。 2. 新生代空间不够")]),v._v(" "),_("li",[v._v("对象不一定达到年龄才进入老年代 ：动态年龄：如果Survivor区里面，所有相同年龄的对象的大小总和大于Survivor空间的一半，那么年龄大于这个年龄的对象会直接进入老年代")])])]),v._v(" "),_("li",[v._v("调优原则：\n"),_("ul",[_("li",[v._v("合理设置Survivor区大小，避免内存浪费")]),v._v(" "),_("li",[v._v("让GC尽可能发生在新生代，避免FullGC")])])])])]),v._v(" "),_("li",[v._v("增量算法\n"),_("ul",[_("li",[v._v("每次只收集一小片内存的垃圾，减少系统的停顿")])])])]),v._v(" "),_("h2",{attrs:{id:"垃圾回收器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[v._v("#")]),v._v(" 垃圾回收器")]),v._v(" "),_("ul",[_("li",[v._v("垃圾回收算法为垃圾回收提供理论支持")]),v._v(" "),_("li",[v._v("垃圾回收器利用垃圾回收算法，实现垃圾回收的实践落地")])]),v._v(" "),_("ol",[_("li",[v._v("术语：\n"),_("ol",[_("li",[v._v("Stop The World：\n"),_("ul",[_("li",[v._v("简写为STW，也叫全局停顿。Java代码停止运行，Native代码继续运行，但是不能与JVM交互")]),v._v(" "),_("li",[v._v("原因：多半由于垃圾回收导致；也可能是Dump线程、死锁检查或Dump堆等")]),v._v(" "),_("li",[v._v("危害：服务停止、没有响应；主从切换，危害生产环境")])])]),v._v(" "),_("li",[v._v("并行收集和并发收集：\n"),_("ul",[_("li",[v._v("并行收集：指多个垃圾收集线程并行工作，但是收集工程中用户线程（业务线程） 还是处于等待状态的")]),v._v(" "),_("li",[v._v("并发收集：指用户线程和垃圾收集线程同时工作")])])]),v._v(" "),_("li",[v._v("吞吐量：\n"),_("ul",[_("li",[v._v("CPU用于运行用户代码的时间与CPU总消耗时间的比值")]),v._v(" "),_("li",[v._v("运行用户代码的时间/（运行用户代码的时间 + 垃圾回收的时间）")])])]),v._v(" "),_("li",[v._v("安全点：\n"),_("ul",[_("li",[v._v("当线程运行到这个位置的时候，线程的一些状态是可以被确定的")]),v._v(" "),_("li",[v._v("这些特定的位置主要有：\n"),_("ol",[_("li",[v._v("循环的末尾")]),v._v(" "),_("li",[v._v("方法临返回前 / 调用方法的call指令后")]),v._v(" "),_("li",[v._v("可能抛异常的位置")])])])])])])]),v._v(" "),_("li",[v._v("Serial\n"),_("ul",[_("li",[v._v("单线程")]),v._v(" "),_("li",[v._v("简单高效，无线程交互的开销")]),v._v(" "),_("li",[v._v("收集过程用户线程全程STW")]),v._v(" "),_("li",[v._v("适用于客户端程序，如：java -client -jar XXX 和 单核机器")])])]),v._v(" "),_("li",[v._v("ParNew\n"),_("ul",[_("li",[v._v("Serial的多线程版本")]),v._v(" "),_("li",[v._v("JVM参数、STW表现和垃圾收集算法 同Serial")]),v._v(" "),_("li",[v._v("多线程，可使用 -XX:ParallelGCThreads设置垃圾收集线程数，一般使用CPU核心数")])])]),v._v(" "),_("li",[v._v("Parallel Scavenge\n"),_("ul",[_("li",[v._v("吞吐量优先收集器")]),v._v(" "),_("li",[v._v("采用的也是复制算法")]),v._v(" "),_("li",[v._v("也是并行的多线程收集器，这一点和 ParNew 类似")]),v._v(" "),_("li",[v._v("可以达到一个可控制的吞吐量\n"),_("ul",[_("li",[v._v("-XX:MaxGCPauseMillis: 控制最大的垃圾收集停顿时间（尽力）")]),v._v(" "),_("li",[v._v("-XX:GCTimeRatio: 设置吞吐量的大小，取值0-100，系统花费不超过1/(1+n)的时间用于垃圾收集")]),v._v(" "),_("li",[v._v("-XX:+UseAdptiveSizePolicy 打开自适应GC策略：打开后无需手动设置新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurviviorRatio）等参数。虚拟机会自动根据系统运行的情况收集性能监控信息，动态地调整这些参数，从而达到最优的的停顿时间以及最高的吞吐量")])])]),v._v(" "),_("li",[v._v("适用于注重吞吐量的场景")])])]),v._v(" "),_("li",[v._v("Serial Old\n"),_("ul",[_("li",[v._v("Serial收集器的老年代版本")]),v._v(" "),_("li",[v._v("标记-整理算法")]),v._v(" "),_("li",[v._v("可以和Serial/ParNew/Parallel Scavenge 这三个新生代的垃圾收集器配合使用")]),v._v(" "),_("li",[v._v("CMS收集器出现故障，也会使用 Serial Old 作为后备")])])]),v._v(" "),_("li",[v._v("Parallel Old\n"),_("ul",[_("li",[v._v("Parallel Scavenge收集器老年代版本")]),v._v(" "),_("li",[v._v("标记-整理算法")]),v._v(" "),_("li",[v._v("只能和Parallel Scavenge配合使用")]),v._v(" "),_("li",[v._v("适用于关注吞吐量的场景")])])]),v._v(" "),_("li",[v._v("CMS\n"),_("ul",[_("li",[v._v("全称：Concurrent Mark Sweep")]),v._v(" "),_("li",[v._v("并发收集器")]),v._v(" "),_("li",[v._v("标记-清除算法")]),v._v(" "),_("li",[v._v("步骤：\n"),_("ol",[_("li",[v._v("初始标记（initial mark）：\n"),_("ul",[_("li",[v._v("标记根对象能直接关联到的对象")]),v._v(" "),_("li",[v._v("STW")])])]),v._v(" "),_("li",[v._v("并发标记（concurrent mark）：\n"),_("ul",[_("li",[v._v("找到所有GC Roots能够关联到的对象，耗时稍长")]),v._v(" "),_("li",[v._v("并发执行，无STW")])])]),v._v(" "),_("li",[v._v("并发预清理（concurrent-perclean）：\n"),_("ul",[_("li",[v._v("重新标记那些在并发标记阶段，引用被更新的对象，从而减少后面重新标记的工作量")]),v._v(" "),_("li",[v._v("并发执行，无STW")]),v._v(" "),_("li",[v._v("可使用 -XX:-CMSPercleaningEable关闭并发预清理阶段，默认打开")])])]),v._v(" "),_("li",[v._v("并发可终止预清理（concurrent-abortable-perclean）：\n"),_("ul",[_("li",[v._v("和 并发预清理 做的事情一样，并发执行，无STW")]),v._v(" "),_("li",[v._v("当Eden的使用量大于CMSScheduleRemarkEdenSizeThrehold的阈值（默认2M）时，才会打开")]),v._v(" "),_("li",[v._v("主要作用：允许我们能够控制预清理阶段的结束时机。比如扫描多长时间（CMSMaxAbortablePrecleanTime,默认5s）,或者Eden区使用占比达到一定阈值（CMSScheduleRemarkEdenPenetration,默认50%）就结束本阶段")])])]),v._v(" "),_("li",[v._v("重新标记（remark）\n"),_("ul",[_("li",[v._v("修正并发期间，因为用户程序继续执行，导致标记发生变动的那些对象的标记")]),v._v(" "),_("li",[v._v("一般来说，重新标记话费的时间要比初试标记阶段长一些，比并发标记的时间短一些")]),v._v(" "),_("li",[v._v("存在STW")])])]),v._v(" "),_("li",[v._v("并发清除（concurrent sweep）："),_("strong",[v._v("标记-清除 算法")]),v._v(" "),_("ul",[_("li",[v._v("基于标记结果，清除掉前面标记出来的垃圾")]),v._v(" "),_("li",[v._v("并发执行，无STW")]),v._v(" "),_("li",[v._v("为何不“并发-整理”呢？ 因为是并发执行，如果整理对象的话需要移动对象的位置，很难保证程序不出问题")])])]),v._v(" "),_("li",[v._v("并发重置（concurrent reset）\n"),_("ul",[_("li",[v._v("清理本次CMS的上下文信息，为下一次GC作准备")])])])])]),v._v(" "),_("li",[v._v("优点：\n"),_("ul",[_("li",[v._v("STW时间短")]),v._v(" "),_("li",[v._v("大多数过程都是并发执行")])])]),v._v(" "),_("li",[v._v("缺点：\n"),_("ul",[_("li",[v._v("CPU资源比较敏感 - 并发阶段可能导致应用吞吐量降低")]),v._v(" "),_("li",[v._v("无法处理浮动垃圾")]),v._v(" "),_("li",[v._v("不能等到老年代几乎满了才开始收集，需预留一部分内存。\n"),_("ul",[_("li",[v._v("预留内存不够 -> Concurrent Mode Failure -> Serial Old作为后备")]),v._v(" "),_("li",[v._v("使用CMSInitiatingOccupancyFraction设置老年代占比达到多少就触发垃圾收集，默认68%")])])]),v._v(" "),_("li",[v._v("内存碎片，基于标记-清除算法\n"),_("ul",[_("li",[v._v("UseCMSCompactAtFullCollection:在full GC后是否要进行内存碎片整理，默认开启")]),v._v(" "),_("li",[v._v("CMSFUllGCsBeforeCompaction：在进行几次full GC后就进行一次内存碎片的整理，默认为0")])])])])]),v._v(" "),_("li",[v._v("适用于希望系统停顿时间短，响应速度快的场景，比如各种服务器应用程序")])])]),v._v(" "),_("li",[v._v("G1\n"),_("ul",[_("li",[v._v("Garbge First")]),v._v(" "),_("li",[v._v("面向服务器端应用的垃圾收集器")]),v._v(" "),_("li",[v._v("G1把Java堆划分成了若干个大小相等的区域，每一个区域叫做region")]),v._v(" "),_("li",[v._v("region的大小可以通过 -XX:G1HeapRegionSize 来指定，取值范围是1～32MB，且必须为2的整数幂")]),v._v(" "),_("li",[v._v("同一个代里面的对象可能是不连续的")]),v._v(" "),_("li",[v._v("Humongous 是用来存储大对象的，某个对象的大小超过了region的一半就认为是大对象。如果一个对象大于一个region的大小，那么会存放在多个连续的region当中。事实上，G1会把Humongous也看作是老年代的一部分")]),v._v(" "),_("li",[v._v("设计思想\n"),_("ul",[_("li",[v._v("内存分块（Region）")]),v._v(" "),_("li",[v._v("跟踪每一个Region中垃圾堆积的价值大小")]),v._v(" "),_("li",[v._v("构建一个优先列表，根据允许的收集时间，优先回收价值高的region")])])]),v._v(" "),_("li",[v._v("垃圾收集机制\n"),_("ul",[_("li",[v._v("Young GC ：\n"),_("ul",[_("li",[v._v("所有的Eden region满了之后，就会触发YoungGC")]),v._v(" "),_("li",[v._v("Eden region的对象都会转移到Survivor Region里面去")]),v._v(" "),_("li",[v._v("原先Survivor Region中的对象会转移到其他的Survivor Region中，或者晋升到Old Region")]),v._v(" "),_("li",[v._v("空闲的Region会被放入空闲列表中，等待下一次被使用")])])]),v._v(" "),_("li",[v._v("Mixed GC\n"),_("ul",[_("li",[v._v("老年代大小占整个堆的百分比达到一定阈值的时候，会触发Mixed GC。可使用 -XX:InitiatingHeapOccupancyPercent 指定，默认45%")]),v._v(" "),_("li",[v._v("Mixed GC会回收所有的Young Region和 "),_("strong",[v._v("部分")]),v._v("（根据回收的时间和垃圾堆积的价值来选择的） Old Region")]),v._v(" "),_("li",[v._v("执行过程：\n"),_("ol",[_("li",[v._v("初始标记（initial mark）：\n"),_("ul",[_("li",[v._v("标记根对象能直接关联到的对象")]),v._v(" "),_("li",[v._v("STW")])])]),v._v(" "),_("li",[v._v("并发标记（concurrent mark）：\n"),_("ul",[_("li",[v._v("找到所有GC Roots能够关联到的对象，耗时稍长")]),v._v(" "),_("li",[v._v("并发执行，无STW")])])]),v._v(" "),_("li",[v._v("最终标记（final mark）\n"),_("ul",[_("li",[v._v("修正并发期间，因为用户程序继续执行，导致标记发生变动的那些对象的标记")]),v._v(" "),_("li",[v._v("存在STW")])])]),v._v(" "),_("li",[v._v("筛选回收（Live Data Counting and Evacuation）:\n"),_("ul",[_("li",[v._v("对各个Region的回收价值和成本进行排序")]),v._v(" "),_("li",[v._v("根据用户所期望的停顿时间（MaxGCPauseMillis）来指定回收计划，并选择一些Region进行回收")]),v._v(" "),_("li",[v._v("回收过程："),_("strong",[v._v("复制 算法")]),v._v(" "),_("ol",[_("li",[v._v("选择一系列Region构成一个回收集set")]),v._v(" "),_("li",[v._v("把决定回收的Region中存活的对象复制到空的Region中")]),v._v(" "),_("li",[v._v("删除掉需回收的Region -> 无内存碎片")]),v._v(" "),_("li",[v._v("筛选阶段存在STW")])])])])])])]),v._v(" "),_("li",[v._v("除了并发标记，其他都存在STW，但是由于只清理堆的部分区域，所以STW的时长是可控的")])])]),v._v(" "),_("li",[v._v("Full GC\n"),_("ul",[_("li",[v._v("复制对象内存不够，或者无法分配足够内存（比如大对象没有连续的Region分配）时，就会触发FullGC")]),v._v(" "),_("li",[v._v("触发FullGC，使用的是Serial Old模式，会长时间STW")])])])])]),v._v(" "),_("li",[v._v("G1优化原则，尽可能减少FullGC的发生，优化思路：\n"),_("ol",[_("li",[v._v("增大预留内存（增大-XX:G1ReservePercent,默认为堆的10%）")]),v._v(" "),_("li",[v._v("更早的回收垃圾（减少 -XX:InitiatingHeapOccupancyPercent，默认45%，老年代达到该值就触发Mixed GC）")]),v._v(" "),_("li",[v._v("增加并发阶段使用的线程数（增大 -XX:ConcGCThreads），会影响吞吐量")])])]),v._v(" "),_("li",[v._v("特点：\n"),_("ol",[_("li",[v._v("作用在整个堆")]),v._v(" "),_("li",[v._v("可控的停顿时间  MaxGCPauseMillis=200")]),v._v(" "),_("li",[v._v("无内存碎片")])])]),v._v(" "),_("li",[v._v("适用场景：\n"),_("ol",[_("li",[v._v("占用内存较大的应用（6G以上）")]),v._v(" "),_("li",[v._v("替换CMS收集器")])])])])])]),v._v(" "),_("blockquote",[_("p",[v._v("Serial：采用复制算法"),_("br"),v._v("\nParallel New（并行）：采用复制算法"),_("br"),v._v("\nParallel Scavenge（并行）：采用复制算法"),_("br"),v._v("\nSerial Old（串行）：采用标记-整理算法"),_("br"),v._v("\nParallel Old（并行）：采用标记-整理算法"),_("br"),v._v("\nCMS：采用标记-清除算法"),_("br"),v._v("\nG1：采用复制算法")])]),v._v(" "),_("ad"),v._v(" "),_("comment")],1)}),[],!1,null,null,null);l.default=e.exports}}]);