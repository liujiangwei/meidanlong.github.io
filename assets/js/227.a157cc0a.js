(window.webpackJsonp=window.webpackJsonp||[]).push([[227],{818:function(a,l,n){"use strict";n.r(l);var s=n(106),t=Object(s.a)({},(function(){var a=this,l=a.$createElement,n=a._self._c||l;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"为什么lamda不能修改外部引用的变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么lamda不能修改外部引用的变量"}},[a._v("#")]),a._v(" 为什么lamda不能修改外部引用的变量？")]),a._v(" "),n("ul",[n("li",[a._v("lamda表达式实际上一个匿名内部类")]),a._v(" "),n("li",[a._v("所以我们的问题可以转向这两个问题：\n"),n("ul",[n("li",[a._v("为什么匿名内部类调用外部引用的时候，外部引用需要用final修饰？")]),a._v(" "),n("li",[a._v("lamda如果才能修改外部引用变量？")])])])]),a._v(" "),n("h2",{attrs:{id:"_1-为什么匿名内部类调用外部引用的时候-外部引用需要用final修饰"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么匿名内部类调用外部引用的时候-外部引用需要用final修饰"}},[a._v("#")]),a._v(" 1. 为什么匿名内部类调用外部引用的时候，外部引用需要用final修饰？")]),a._v(" "),n("ul",[n("li",[a._v("我们在内部类中调用外部的自由变量，即使该变量没有显式的声明final，但是在编译器解析的时候也被定义成一个final变量")]),a._v(" "),n("li",[a._v("这里java内部类引用外部变量近似闭包的概念。我们先来了解一下js中满足闭包的条件：\n"),n("ol",[n("li",[a._v("一个依赖于外部环境自由变量的函数")]),a._v(" "),n("li",[a._v("这个函数能够访问外部环境里的自由变量")])])]),a._v(" "),n("li",[a._v("闭包常见使用场景\n"),n("ol",[n("li",[a._v("回调函数")]),a._v(" "),n("li",[a._v("匿名函数")])])]),a._v(" "),n("li",[a._v("在闭包中访问外部自由变量访问的是自由变量的哪个值呢？\n"),n("ul",[n("li",[a._v("是闭包"),n("strong",[a._v("定义")]),a._v("时，自由变量所定义的值（非运行时！）")])])]),a._v(" "),n("li",[a._v("js中通常我们要解决闭包导致对象不正确问题，常用的有四个解决方案：\n"),n("ol",[n("li",[a._v("func.call(obj, 20, 30)")]),a._v(" "),n("li",[a._v("func.apply(obj, [20,30])")]),a._v(" "),n("li",[a._v("const func1 = func.bind(obj,20,30)")]),a._v(" "),n("li",[a._v("在闭包外方法中手动指定 let self = this")])])]),a._v(" "),n("li",[a._v("说到闭包，绕不开this指向问题，this应该指向的是"),n("strong",[a._v("运行")]),a._v("时的对象，简单总结this指向三种情况：\n"),n("ol",[n("li",[a._v("obj.func() -> this指向"),n("code",[a._v(".")]),a._v("前面调用的对象，此时指向obj")]),a._v(" "),n("li",[a._v("new Fun() -> this指向new出来的对象")]),a._v(" "),n("li",[a._v("函数自调、匿名函数和回调函数 -> this指向的是window")])])]),a._v(" "),n("li",[a._v("java对闭包的处理\n"),n("ol",[n("li",[a._v("如函数在使用类的全局变量的时候\n"),n("ul",[n("li",[a._v("全局变量实际是类的一个属性，用this指向，可所以修改")])])]),a._v(" "),n("li",[a._v("但是在处理匿名内部类的时候，在不同的类中无法用this指向，这时java的做法是：\n"),n("ul",[n("li",[a._v("将自由变量拷贝一个副本带给匿名内部类，供内部类使用。")]),a._v(" "),n("li",[a._v("类似于值传递而非引用传递")])])])])])]),a._v(" "),n("h2",{attrs:{id:"_2-lamda如果才能修改外部引用变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-lamda如果才能修改外部引用变量"}},[a._v("#")]),a._v(" 2. lamda如果才能修改外部引用变量？")]),a._v(" "),n("ol",[n("li",[a._v("数组")]),a._v(" "),n("li",[a._v("全局变量")]),a._v(" "),n("li",[a._v("atomicReference")])]),a._v(" "),n("h2",{attrs:{id:"_3-参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-参考"}},[a._v("#")]),a._v(" 3. 参考")]),a._v(" "),n("div",{staticClass:"language-md line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[a._v("lamda不能修改外部引用的变量的原因其实也很简单，本质上就是因为lambda表达式在方法内部，那么lambda表达式的内存分配就是在栈上。栈内存不存在线程安全问题，因为栈内存存的都是变量的副本。\n对于局部变量count而言，它的生命周期就是所在方法的生命周期。这就决定了count无法被位于同一个栈帧上的lambda修改，因为这种修改毫无意义，\n你无法将你的修改传递出当前栈帧。栈内存不会被共享，也就意味着你没有权利和其他栈帧通信。\n\n如果非要在lambda内部修改lambda表达式外部的局部变量的值呢？\n有两种方式：使用数组或者把局部变量定义为全局变量。\n\n这2种方式，其实本质是一样的：内存都分配在堆上。这就决定了，使用这2种方式来修改变量的值，是可行的。\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br")])]),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/reggergdsg/article/details/103287400",target:"_blank",rel:"noopener noreferrer"}},[a._v("如何在lambda内部修改外部局部变量的值/如何用lambda重构for循环计数 -> 春秋战国程序猿"),n("OutboundLink")],1)]),a._v(" "),n("ad"),a._v(" "),n("comment")],1)}),[],!1,null,null,null);l.default=t.exports}}]);