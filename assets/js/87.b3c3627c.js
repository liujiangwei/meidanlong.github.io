(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{974:function(t,e,r){"use strict";r.r(e);var a=r(106),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"reactive-programming模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reactive-programming模型"}},[t._v("#")]),t._v(" Reactive Programming模型")]),t._v(" "),r("h2",{attrs:{id:"一-模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一-模型"}},[t._v("#")]),t._v(" 一. 模型")]),t._v(" "),r("blockquote",[r("p",[t._v("参考资源："),r("a",{attrs:{href:"https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-programming-models",target:"_blank",rel:"noopener noreferrer"}},[t._v("WebFlux 编程模型"),r("OutboundLink")],1)])]),t._v(" "),r("h3",{attrs:{id:"_1-语言模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-语言模型"}},[t._v("#")]),t._v(" 1. 语言模型")]),t._v(" "),r("p",[t._v("响应式编程 + 函数式编程（可选）")]),t._v(" "),r("h3",{attrs:{id:"_2-并发模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-并发模型"}},[t._v("#")]),t._v(" 2. 并发模型")]),t._v(" "),r("p",[t._v("多线程编程")]),t._v(" "),r("h3",{attrs:{id:"_3-对立模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-对立模型"}},[t._v("#")]),t._v(" 3. 对立模型")]),t._v(" "),r("p",[t._v("命令式编程（Imperative programming）")]),t._v(" "),r("blockquote",[r("p",[t._v("Reactive Programming：同步或异步非阻塞执行，数据传播被动通知"),r("br"),t._v("\nImperative programming：同步阻塞执行，数据主动获取")])]),t._v(" "),r("h2",{attrs:{id:"二-数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二-数据结构"}},[t._v("#")]),t._v(" 二. 数据结构")]),t._v(" "),r("blockquote",[r("p",[t._v("A stream is a sequence of ongoing events ordered in time")])]),t._v(" "),r("h3",{attrs:{id:"_1-流式-streams"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-流式-streams"}},[t._v("#")]),t._v(" 1. 流式（Streams）")]),t._v(" "),r("h3",{attrs:{id:"_2-序列-sequences"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-序列-sequences"}},[t._v("#")]),t._v(" 2. 序列（Sequences）")]),t._v(" "),r("h3",{attrs:{id:"_3-事件-events"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-事件-events"}},[t._v("#")]),t._v(" 3. 事件（Events）")]),t._v(" "),r("h2",{attrs:{id:"三-设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三-设计模式"}},[t._v("#")]),t._v(" 三. 设计模式")]),t._v(" "),r("h3",{attrs:{id:"_1-扩展模式-观察者-observer-push-based"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-扩展模式-观察者-observer-push-based"}},[t._v("#")]),t._v(" 1. 扩展模式：观察者（Observer） -> push-based")]),t._v(" "),r("h3",{attrs:{id:"_2-对立模式-迭代器-iterator-pull-based"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-对立模式-迭代器-iterator-pull-based"}},[t._v("#")]),t._v(" 2. 对立模式：迭代器（Iterator） -> pull-based")]),t._v(" "),r("h3",{attrs:{id:"_3-混合模式-反应堆-reactor同步非阻塞-、proactor异步非阻塞"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-混合模式-反应堆-reactor同步非阻塞-、proactor异步非阻塞"}},[t._v("#")]),t._v(" 3. 混合模式：反应堆（Reactor同步非阻塞）、Proactor异步非阻塞")]),t._v(" "),r("p",[r("strong",[t._v("对比：")])]),t._v(" "),r("p",[t._v("An Observable(RxJava) is the asynchronous/push “dual” to the synchronous/pull Iterable")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[t._v("eventIterable")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("Iterable (pull)")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("Observable (push)")])])]),t._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("data")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[r("code",[t._v("T next()")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[r("code",[t._v("onNext(T)")])])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("discover error")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("throws "),r("code",[t._v("Exception")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[r("code",[t._v("onError(Exception)")])])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("complete")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[r("code",[t._v("!hasNext()")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[r("code",[t._v("onCompleted()")])])])])]),t._v(" "),r("p",[r("strong",[t._v("结论：")])]),t._v(" "),r("p",[t._v("Reactive Programming 作为观察者模式（Observer）的延伸，在处理流式数据的过程中，并非使用传统的命令编程方式（Imperative programming）同步拉取数据，\n如迭代器模式（Iterator），而是采用同步或异步非阻塞地推拉相结合的方式，响应数据传播时的变化")]),t._v(" "),r("h2",{attrs:{id:"四-并发模型-concurrency-model"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四-并发模型-concurrency-model"}},[t._v("#")]),t._v(" 四. 并发模型（Concurrency Model）")]),t._v(" "),r("ul",[r("li",[t._v("非阻塞（Non-Blocking）\n"),r("ul",[r("li",[t._v("同步（Synchronous）")]),t._v(" "),r("li",[t._v("异步（Asynchronous）")])])])]),t._v(" "),r("p",[r("strong",[t._v("结论：")])]),t._v(" "),r("p",[t._v("屏蔽并发编程细节，如线程、同步、线程安全以及并发数据结构")]),t._v(" "),r("ad"),t._v(" "),r("comment")],1)}),[],!1,null,null,null);e.default=s.exports}}]);